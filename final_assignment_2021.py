# -*- coding: utf-8 -*-
"""Final_Assignment_2021.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/104xrDhXlSdLWB-Ft-whiKjuS_jDqGPEW

## Final Assignment

### About the data

The data were obtained in a survey of students math and portuguese language courses in secondary school. It contains a lot of interesting social, gender and study information about students. 

Attributes for both student-mat.csv (Math course) and student-por.csv (Portuguese language course) datasets

https://archive.ics.uci.edu/ml/datasets/STUDENT+ALCOHOL+CONSUMPTION

I have defined three resarch questions for this dataset:

* Is there a significant difference between alcohol consumption and the parents education?

* Is there a significant difference between alcohol consumption and the parents job?

* does alcohol consumption during the weekend influence the students final grade?

Some Information about Columns name:
1. Medu = Mother's education (numeric: 0 - none, 1 - primary 
education (4th grade), 2 - 5th to 9th grade, 3 - secondary and
2. Fedu = Father's education (numeric: 0 - none, 1 - primary education (4th grade), 2 - 5th to 9th grade, 3 - secondary
3. Mjob = Mother's job (nominal: 'teacher', 'health' care related, civil 'services' (e.g. administrative or police), 'at_home' 
4. Fjob = Father's job (nominal: 'teacher', 'health' care related, civil 'services' (e.g. administrative or police), 'at_home' 
5. Walc = Weekend alcohol consumption (numeric: from 1 - very low to 5 - very high)
6. G3 = Final Grade in exam (numeric: from 0 to 20, output target)
7. Health = Current health status (numeric: from 1 - very bad to 5 - very good)

# part 1: load the data
"""

import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
import seaborn as sns
from sklearn import preprocessing
import statsmodels.api as sm
from scipy.stats import norm,binom
from abc import ABC, abstractmethod
import seaborn

"""#load data"""

#load portoguese dataset
df1 = pd.read_csv("student-por.csv")
# add a column " calsses" for merging
df1['classes']='Portuguese'

#load math dataset
df2 = pd.read_csv("student-mat.csv")
# add a column " calsses" for merging
df2['classes']='Math'

#inorder to reuse the code and use the capabilities of seaborn we merge the dataframes
df=pd.concat([df1, df2], axis=0)
#using concat function only copy and pastes the indices so we should rest them to see it as a whole dataframe
df.reset_index(inplace=True , drop=True)

# To see the description of dataset for the 'numerical' columns
df.describe()

#use certain columns for our work and drop others instead of droping lots of values
df=df[['G1' , 'G2' , 'G3' , 'Medu' , 'Fedu' , 'Walc' ,'Dalc', 'Fjob' , 'Mjob' , 'health','sex', 'classes', 'age']]

"""# part 2: data inspection
- What functions can be in a class?
- What would be the responsibility of the class?
- Can I make an abstract class and use a concrete instantiation?
- Are there design patterns I can use?

"""

#why a distinct class: all plots are from seaborn
class SNS_Plotter():
  #Each function get the column : 'value' 
  #ax_list: for all of axis of the plots
  # i: the index of that plot we are plotting in
  #hue : predefined : if not defined use the hue of classes
  #title : value
  def __init__(self, data):
    self. data=data
    
  def histplot(self , value ,  ax_list,i,hue='classes'):
    ax=ax_list[i]
    seaborn.histplot(data=self.data , x=value,hue=hue,multiple='stack', ax=ax, binwidth=1, kde=True)
    ax.set_title(value)

  def countplot(self , value , ax_list,i,hue='classes'):
    ax=ax_list[i]
    seaborn.countplot(data=self.data , x=value,hue=hue, ax=ax)
    ax.set_title(value)

  def boxplot(self ,  value , ax_list,i, hue=None, palette=None,y='classes'):
    ax=ax_list[i]
    seaborn.boxplot(data=self.data , x=value,ax=ax , y=y, hue=hue,showmeans=True,meanprops={"marker": "o",
                       "markeredgecolor": "limegreen",
                       "markersize": "10"},palette=palette)
    ax.set_title(value)
    
  def correlation_map(self,value,ax_list,i):
    ax=ax_list[i]
    #I used the heatmap of seaborn to make the correlation plots which makes all the code easier for me
    seaborn.heatmap(self.data.query("classes =='%s'"% value).corr(), cmap="PiYG", annot=True, vmax=1, vmin=-1,ax=ax, cbar_kws={'label': 'Correlation coeff'})
    ax.set_title(value)

#why:  statistics_plotter uses the instance of inner class to "only" plot the values
#There is my_statistics which calculates the values for each data column that we are going to plot them(Inner class)
class statistics_plotter:
  #Start of inner class
  class my_statistics:
    #constructor: only gets the data
    def __init__(self, data):
      self. data=data
    #statistics calculator for QQ plot of the dataframe column
    def Q_Q_calc(self , column):
      y=self.data[column]
      n = len(y)
      # Calculate order statistic:
      y_os = np.sort(y)
      # Estimates of mu and sigma:
      # ML estimates:
      mu = np.mean(y)
      sigma2_ML = np.mean((y - mu)**2)
      sigma_ML = np.sqrt(sigma2_ML) # biased estimate
      s2 = n/(n-1) * sigma2_ML
      sigma = np.sqrt(s2) # unbiased estimate
      # Perform z-transform: sample quantiles z.i
      z_i = (y_os - mu)/sigma
      # Calculate cumulative probabilities p.i:
      i = np.array(range(n)) + 1
      p_i = (i - 0.5)/n
      # Calculate theoretical quantiles z.(i):
      z_th = norm.ppf(p_i, 0, 1)
      # Calculate SE or theoretical quantiles:
      SE_z_th = (1/norm.pdf(z_th, 0, 1)) * np.sqrt((p_i * (1 - p_i)) / n)
      # Calculate 95% CI of diagonal line:
      CI_upper = z_th + 1.96 * SE_z_th
      CI_lower = z_th - 1.96 * SE_z_th
      return z_th , z_i , CI_upper,CI_lower

    #Estimator for dataframe column for two cases : normal , binomal  
    def normal_binomial(self , column):
        # get the column
        y=self.data[column]
        #store the Min value
        Min_value= y.min()
        #subtract min
        y = y - Min_value
        #distinct values of column
        k = y.unique().size
        #parameter estimates
        p = (1/k) * y.mean()
        #Mean for normal
        mu=y.mean()
        #calculation for standard deviation
        sigma = np.sqrt(k * p * (1 - p))
        return mu, sigma , k , p, Min_value

#start of higher class
  def __init__(self, data):
    #use the instance of inner class using the data frame as a worker of our higher class
    self.stat=self.my_statistics(data)
  #plot normal and binomial estimation : ax_list and the locarion of it "j" and value :" columns"
  def plot_norm_binomial(self, value ,ax_list,j):
      mu, sigma , k , p,min_value=self.stat.normal_binomial(value)
      i=list(range(k))
      x = np.arange(0,k,0.01)
      f_i = binom.pmf(i, k, p)
      f_N = norm.pdf(x,  mu, sigma)
      #plot
      ax=ax_list[j]
      ax.vlines(i, 0, f_i, colors='k', linestyles='-', lw=1,label='$Bin(${:d}, {:.3f}$)$ distribution'.format(k, p))
      ax.plot(x, f_N, 'r', label='$N(${:.3f}, {:.3f}$)$ approximation'.format(mu, sigma**2))
      ax.set_xlabel(f'{value}, $y$')
      ax.set_ylabel('Probability, $f(y)$')
      ax.legend(loc='best')
      xticks = np.arange(0, k)
      xticks_label = (xticks + min_value).astype('int')
      ax.set_xticks(xticks)
      ax.set_xticklabels(xticks_label)
      ax.set_title(value )
  #QQplotter  : ax_list and the locarion of it "j" and value :" columns"
  def Q_Q_plot(self , value ,ax_list,i):
    ax=ax_list[i]
    z_th , z_i , CI_upper,CI_lower=self.stat.Q_Q_calc(value)
    ax.plot(z_th, z_i, 'o', color='k', label='experimental data', alpha=0.1)
    ax.plot(z_th, z_th, '--', color='r', label='normal line')
    ax.plot(z_th, CI_upper, '--', color='b', label='95% CI')
    ax.plot(z_th, CI_lower, '--', color='b')
    ax.set_xlabel('Theoretical quantiles, $z_{(i)}$')
    ax.set_ylabel('Sample quantiles, $z_i$')
    ax.set_title('Q-Q plot ' +value )
    ax.legend(loc='best')

#plotter inherits the statistics_plotter and SNS_Plotter to use both of classes functions (Abstract class)
class Plotter(statistics_plotter,SNS_Plotter):
  def __init__(self, data):
    statistics_plotter.__init__(self, data)
    SNS_Plotter.__init__(self, data)
  #we should use the functions in SNS_Plotter to generate a more complex plot because sns plots are simple and similar to function of seaborn
  def score_plot(self,column,ax,i):
      self.histplot(column,  ax,i)
      self.boxplot(column, ax,i+3)
      self.boxplot(column, ax,i+6,'sex','Set3')
  # I have a function wich I will implement it later using the higher class
  @abstractmethod
  def all(self , function , List  , nrows , ncols, title):
    pass

#The class with only one function : generate subplots to compare plots easier
class Plot_Initializer:
  #__call__ if I call the instance of the class it will work with the function below
  def __call__(self,nrows , ncols, dpi=150,suptitle='' ):
    #nrows:number of rows in plot
    #ncols: number of cols in plot
    # for each subplot we should have a margin and 8: width , 6: height
    #dpi is fixed but can be changed to any preferred values
    #sup title: Big title for all of the subplots
    fig , ax= plt.subplots(nrows=nrows , ncols=ncols , figsize=(ncols*8 , nrows*6), dpi=dpi)
    if nrows!=1 and ncols!=1:
      ax=ax.flat
    fig.suptitle(suptitle, fontsize=32)
    #return axlist and frame
    return fig ,ax

#Prof_Plotter : professional plotter which uses the abstract class of plotter and uses the instance of initializer

class Prof_Plotter(Plotter):
  def __init__(self, data):
    Plotter.__init__(self,data)
    self.initializer=Plot_Initializer()
  #I need to implement the abstrct function
  # function : any of functions which plots what we need : da.plotter.all(da.plotter.score_plot,['G1' , 'G2' , 'G3'],nrows=3,ncols=3,title='Scoreplot')
  #List : different columns to plot
  #ncols : number of columns of subploys
  #nrows: number of rows of subplots
  #Title : title for plots
  def all(self , function , List  , nrows , ncols, title):
    #initialize the list of axis and frame
    fig , ax=self.initializer(nrows , ncols,suptitle=title)
    for i ,v in enumerate(List):
      # for each of values: columns in the List performs the function of the specific location using axis list and index
        function(v,ax,i)

# all we did was a try to make plots
#but now we are going to perform the statistical test
class OLS:
  #oncoder : 
  class encoder:
    def __init__(self, data):
      self. data=data
    def encode(self , c):
      # in order to fix the problem of making a dictionary for all values I used the lable encoder which is made for this work
      le = preprocessing.LabelEncoder()
      self. data[c]=le.fit_transform(self. data[c])
    def encode_all(self, List: list):
      for c in List:
        self.encode(c)
    def get_data(self):
      return self.data

  def __init__(self, data):
    self. data=data
    self.enc=self.encoder(data)

  def __call__(self,values):
      self.enc.encode_all(['Fjob' , 'Mjob'])
      data_copy=self.enc.get_data()
      data_copy['Pedu']=data_copy['Medu'].astype(str)+' '+data_copy['Fedu'].astype(str)
      data_copy['Pjob']=data_copy['Mjob'].astype(str)+' '+data_copy['Fjob'].astype(str)
      self.data=data_copy
      formula='self.data.'+values[0]+'~'+ 'self.data.'+values[1]
      model =sm.OLS.from_formula( formula=formula, data= self.data ).fit()
      anova_table = sm.stats.anova_lm(model, typ=2)
      print(anova_table)

# a class for data analysis
class data_analysis:
  def __init__(self, data):
    #get the data
    self. data=data
    # uses a plotter
    self.plotter=Prof_Plotter(data)
    #performs Ols model
    self.ols=OLS(data)

da=data_analysis(df)

"""#All plots
1. Score plot
2. categorical values plot 
3. Correlation map

comparing G1,G2, and G3, we can see that most passed number 
of studetns are the ones who got 10 or 1 point fewer or more in every semester.

the numbder of students who got 0 in G2 and G3 has increased signifcantly. 

the only time that students managed to get full mark is the final semester. 

There is not a considerable difference between the number of passed students in Math and Portuguese 



The average number of passed students has increased from mark 11 to 12.5 for Portoguese classes
but the average number of passed students for math did not have a big difference in number and grades



the average mark of male students both in math and portoguese is a same number 10-11
however the aveerage number of passed felamle students in math is lower than portoguese by 1 mark 10
in all semseters

As we can see here,

the number of unejucated mothers are nearly none and there is no big difference in numbers for primary educated, secondary and so on.

the number of students whose mothers work in health category is the lowest nearly 50
and the most number of students mothers mentioned other jobs. 

there is no such a big difference between the Math and Portuguese students in alchohol cunsumption 


students at the age of 16-17 have the biggest proportion of the data and the lowest number goes to the ones at the age of 20-22

the number of uneducated fathers is nearlt 0 and there is no difference between the number of primary secondary and so on
"""

da.plotter.all(da.plotter.score_plot,['G1' , 'G2' , 'G3'],nrows=3,ncols=3,title='Scoreplot')

da.plotter.all(da.plotter.countplot,['Medu' , 'Mjob' ,'Dalc' ,'age' ,'Fedu','Fjob' , 'Walc','health'],nrows=2,ncols=4,title='Categorical values plot')

da.plotter.all(da.plotter.correlation_map,['Portuguese','Math'],nrows=1,ncols=2,title='Correlation map')

"""# Part 3: Check Assumptions

##My research questions are

*Is there a significant difference between alcohol consumption and the parents education?

*Is there a significant difference between alcohol consumption and the parents job?
"""

da.ols(['Walc' , 'Pjob'])

da.ols(['Walc' , 'Pedu'])

"""##QQ plot"""

da.plotter.all(da.plotter.Q_Q_plot,['Walc','Dalc','age','G1' , 'G2' , 'G3'],nrows=2,ncols=3,title='QQ')

"""#Normal -binomial estimation"""

da.plotter.all(da.plotter.plot_norm_binomial,['Walc','Dalc','age','G1' , 'G2' , 'G3'],nrows=2,ncols=3,title='Binomial/Normal')

"""# To be edited

from a first visual inspection we can state the following:
We can state that: 
Subjects with low Walc (1,2) are getting marks higher than 6 to 19 except one 0 

Subjects with medium Walc (3) are getting marks from 8 to 18 and females are in a good status 

Subjects with high Walc (4,5) contains the highest number of failed ones, however there is an exception which has the highest number among all
Based on the scatter plot above, there is no influence of alcohol consumption on final grade, for the Portuguese course stuedents.
Here as a same data type with diffrent group of student as portuguese lesson
We can state that 
Subjects with low Walc( 1 ) are mostly getting higher marks than the others 

Subjects with medium Walc (2-3) females are getting the highest and the lowest marks 4,5,6 and 17,18

Subjects woth high Walc (5) are getting average G3 from 7 to 13
Based on the heatmap for both data frame, we can draw the following conclusions regarding the research questions:

There are  positive correlation between student grades and Alcohol consumption .
There are positive correlation between parents education and Alcohol consumption .
The job of parents has effect on Alcohol consumption in teenager.
from the scatter plot it can be observed that in the weekend the alcohol consumption in the male students is more than female students. but it seems that in general alcohol consumption in the weeken does not influence the final grade (G3).
The box plot above also confirm the result of the previous scatter plot. walc does not influence the G3. and male students consume more ahcohol during the weekend.
Boxplot shows that the health condition of the stuendts that consume less alcohol better than the others(category 4 and 5). this is more obvious in the data of male students.
Form this data we can conclude that the students who have raised by the higher educated parents drink less alcohol and at the same time parents job could influnce student alcohol consumption.
Furthere more,Alcohol consumption did not show any eefect on final grade of the students also male students drink more alcohol than female students during the weekend.
There is a significant difference between the alcohol consumption in comparison with the jobs of the parents (p=0.000209 < 0.05).

Discussion:

Data has no equal sample size
It contains only data from students following mathematics and portuguese lessons. Therefore, it is only a small sample out of a varying population. Thus, this is only representative for these students.
There is a significant difference between the alcohol consumption in comparison with the education of the parents (p= 0.003396 < 0.05).
The Q_Q_Plot does not show a normal distribution because it expects countinues data and not discrete data
Here we can ilustrate the alcohol cunsumption flactuated in students who has low education level mother.
In this plot as we can see there is no diffrence between fathe's education and drinking alcohol.
As we can see here the students who their fathers job is teacher drink less alcohol during the weekend than the students that their fathers have different jobs.
Source Information
P. Cortez and A. Silva. Using Data Mining to Predict Secondary School Student Performance. In A. Brito and J. Teixeira Eds., Proceedings of 5th FUture BUsiness TEChnology Conference (FUBUTEC 2008) pp. 5-12, Porto, Portugal, April, 2008, EUROSIS, ISBN 978-9077381-39-7.

Fabio Pagnotta, Hossain Mohammad Amran.
Email:fabio.pagnotta@studenti.unicam.it, mohammadamra.hossain '@' studenti.unicam.it
University Of Camerino

https://archive.ics.uci.edu/ml/datasets/STUDENT+ALCOHOL+CONSUMPTION
https://www.kaggle.com/uciml/student-alcohol-consumption
"""